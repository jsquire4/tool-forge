#!/usr/bin/env node
// ============================================================================
// MCP Server Bundle Template — TypeScript (Node)
//
// Generated by /forge-mcp in bundle mode. Registers multiple related tools
// under a single MCP server identity.
//
// When to use bundle mode:
//   - Tools share the same external API (e.g., weather: current + forecast + air quality)
//   - Tools form a logical domain group (e.g., portfolio: holdings + performance + dividends)
//   - You want a single process / single stdio pipe for a set of related tools
//
// When to use single-tool mode instead:
//   - Tools call different external APIs with different auth
//   - Tools have incompatible dependency requirements
//   - You want to deploy/version tools independently
// ============================================================================

import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod";

// ── Configuration ───────────────────────────────────────────────────────────

// EXTENSION POINT: Shared configuration for all tools in this bundle.
// Tools that share an API should share a base URL and credentials.
const API_BASE_URL = process.env.{{SERVICE_PREFIX}}_BASE_URL || "https://api.example.com/v1";
const API_KEY = process.env.{{SERVICE_PREFIX}}_API_KEY;

// ── Server ──────────────────────────────────────────────────────────────────

const server = new McpServer({
  name: "{{service}}-mcp-server",
  version: "{{version}}"
  // version should track the highest tool version in the bundle,
  // or use an independent bundle version if tools are versioned separately
});

// ============================================================================
// Tool Registrations
//
// Each tool maps from a ToolDefinition. The overlap map suggests natural
// groupings — tools in the same cluster are candidates for bundling.
//
// Pattern per tool:
//   1. Define input schema (from ToolDefinition.schema)
//   2. Register with annotations (from ToolDefinition.category + consequenceLevel)
//   3. Implement handler (from ToolDefinition.execute)
// ============================================================================

// ── Tool 1: {{tool_1_name}} ─────────────────────────────────────────────────

const {{Tool1Name}}InputSchema = z.object({
  // EXTENSION POINT: Fields from ToolDefinition.schema
}).strict();

server.registerTool(
  "{{tool_1_name}}",
  {
    title: "{{Tool 1 Display Name}}",
    description: `{{tool_1_description — full routing contract}}`,
    inputSchema: {{Tool1Name}}InputSchema,
    annotations: {
      readOnlyHint: true,       // from category: 'read'
      destructiveHint: false,
      idempotentHint: true,
      openWorldHint: true
    }
  },
  async (params) => {
    try {
      // EXTENSION POINT: Tool 1 implementation
      const data = await callApi("/{{tool_1_endpoint}}", params);
      return {
        content: [{ type: "text" as const, text: formatTool1(data) }],
        structuredContent: data
      };
    } catch (error) {
      return {
        content: [{ type: "text" as const, text: `Error: ${error instanceof Error ? error.message : String(error)}` }],
        isError: true
      };
    }
  }
);

// ── Tool 2: {{tool_2_name}} ─────────────────────────────────────────────────

const {{Tool2Name}}InputSchema = z.object({
  // EXTENSION POINT: Fields from ToolDefinition.schema
}).strict();

server.registerTool(
  "{{tool_2_name}}",
  {
    title: "{{Tool 2 Display Name}}",
    description: `{{tool_2_description — full routing contract}}`,
    inputSchema: {{Tool2Name}}InputSchema,
    annotations: {
      readOnlyHint: true,
      destructiveHint: false,
      idempotentHint: true,
      openWorldHint: true
    }
  },
  async (params) => {
    try {
      // EXTENSION POINT: Tool 2 implementation
      const data = await callApi("/{{tool_2_endpoint}}", params);
      return {
        content: [{ type: "text" as const, text: formatTool2(data) }],
        structuredContent: data
      };
    } catch (error) {
      return {
        content: [{ type: "text" as const, text: `Error: ${error instanceof Error ? error.message : String(error)}` }],
        isError: true
      };
    }
  }
);

// ── Tool N: {{tool_N_name}} ─────────────────────────────────────────────────
//
// EXTENSION POINT: Repeat the pattern above for each additional tool.
// The /forge-mcp skill generates one registration block per ToolDefinition
// in the bundle. Delete this placeholder when generating real tools.

// ── Shared API Client ───────────────────────────────────────────────────────

// EXTENSION POINT: Shared client for all tools in the bundle.
// If tools call different endpoints on the same API, they share this function.
// If tools call completely different APIs, split into separate MCP servers.
async function callApi(endpoint: string, params: Record<string, unknown>): Promise<Record<string, unknown>> {
  const queryString = new URLSearchParams(
    Object.entries(params).map(([k, v]) => [k, String(v)])
  ).toString();

  const url = `${API_BASE_URL}${endpoint}${queryString ? `?${queryString}` : ""}`;

  const response = await fetch(url, {
    headers: {
      "Content-Type": "application/json",
      ...(API_KEY ? { "Authorization": `Bearer ${API_KEY}` } : {})
    },
    signal: AbortSignal.timeout(15000)
  });

  if (!response.ok) {
    throw new Error(`API error: ${response.status} ${response.statusText}`);
  }

  return response.json() as Promise<Record<string, unknown>>;
}

// ── Formatting Functions ────────────────────────────────────────────────────

// EXTENSION POINT: One formatter per tool for human-readable output.
function formatTool1(data: Record<string, unknown>): string {
  return JSON.stringify(data, null, 2);
}

function formatTool2(data: Record<string, unknown>): string {
  return JSON.stringify(data, null, 2);
}

// ── Main ────────────────────────────────────────────────────────────────────

async function main() {
  if (!API_KEY) {
    console.error("WARNING: {{SERVICE_PREFIX}}_API_KEY not set.");
  }

  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error("{{service}}-mcp-server running via stdio — {{N}} tools registered");
}

main().catch(error => {
  console.error("Server error:", error);
  process.exit(1);
});
