#!/usr/bin/env node
// ============================================================================
// MCP Server Template — TypeScript (Node)
//
// Generated by /forge-mcp from a ToolDefinition.
// Replace all {{placeholders}} and EXTENSION POINT sections.
// ============================================================================

import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod";

// ── Configuration ───────────────────────────────────────────────────────────

// EXTENSION POINT: Set your API base URL and credentials
const API_BASE_URL = process.env.API_BASE_URL || "https://api.example.com/v1";
const API_KEY = process.env.API_KEY;

// ── Server ──────────────────────────────────────────────────────────────────

const server = new McpServer({
  name: "{{service}}-mcp-server",
  version: "1.0.0"
});

// ── Input Schema ────────────────────────────────────────────────────────────

// EXTENSION POINT: Define your input schema using Zod
const {{ToolName}}InputSchema = z.object({
  // Example fields:
  // query: z.string().min(1).describe("Search query"),
  // limit: z.number().int().min(1).max(100).default(20).describe("Max results"),
}).strict();

type {{ToolName}}Input = z.infer<typeof {{ToolName}}InputSchema>;

// ── Tool Registration ───────────────────────────────────────────────────────

server.registerTool(
  "{{tool_name}}",
  {
    title: "{{Tool Display Name}}",
    description: `{{description — the full routing contract from ToolDefinition}}`,
    inputSchema: {{ToolName}}InputSchema,
    annotations: {
      readOnlyHint: true,     // EXTENSION POINT: set based on tool category
      destructiveHint: false,  // EXTENSION POINT: set based on consequence level
      idempotentHint: true,    // EXTENSION POINT: set based on tool behavior
      openWorldHint: true      // true if tool calls external APIs
    }
  },
  async (params: {{ToolName}}Input) => {
    try {
      // EXTENSION POINT: Implement the tool's logic
      // This maps to the ToolDefinition's execute() function
      const data = await callApi(params);

      // Format for human display
      const textContent = formatResponse(data);

      return {
        content: [{ type: "text" as const, text: textContent }],
        structuredContent: data
      };
    } catch (error) {
      return {
        content: [{
          type: "text" as const,
          text: `Error: ${error instanceof Error ? error.message : String(error)}`
        }],
        isError: true
      };
    }
  }
);

// ── API Client ──────────────────────────────────────────────────────────────

// EXTENSION POINT: Replace with your actual API call
async function callApi(params: {{ToolName}}Input): Promise<Record<string, unknown>> {
  const response = await fetch(`${API_BASE_URL}/{{endpoint}}`, {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
      ...(API_KEY ? { "Authorization": `Bearer ${API_KEY}` } : {})
    },
    signal: AbortSignal.timeout({{timeout}}),
  });

  if (!response.ok) {
    throw new Error(`API error: ${response.status} ${response.statusText}`);
  }

  return response.json() as Promise<Record<string, unknown>>;
}

// ── Formatting ──────────────────────────────────────────────────────────────

// EXTENSION POINT: Format the response for human readability
function formatResponse(data: Record<string, unknown>): string {
  // Return markdown-formatted text for human consumption
  // The structuredContent field handles machine consumption
  return JSON.stringify(data, null, 2);
}

// ── Main ────────────────────────────────────────────────────────────────────

async function main() {
  if (!API_KEY) {
    console.error("WARNING: API_KEY not set. Some operations may fail.");
  }

  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error("{{service}}-mcp-server running via stdio");
}

main().catch(error => {
  console.error("Server error:", error);
  process.exit(1);
});
