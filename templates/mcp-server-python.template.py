#!/usr/bin/env python3
"""
MCP Server Template — Python (FastMCP)

Generated by /forge-mcp from a ToolDefinition.
Replace all {{placeholders}} and EXTENSION POINT sections.
"""

import os
import json
from typing import Optional, Dict, Any

import httpx
from pydantic import BaseModel, Field, ConfigDict
from mcp.server.fastmcp import FastMCP

# ── Configuration ────────────────────────────────────────────────────────────

# EXTENSION POINT: Set your API base URL and credentials
API_BASE_URL = os.environ.get("API_BASE_URL", "https://api.example.com/v1")
API_KEY = os.environ.get("API_KEY")
TIMEOUT = {{timeout}} / 1000  # Convert ms to seconds

# ── Server ───────────────────────────────────────────────────────────────────

mcp = FastMCP("{{service}}_mcp")

# ── Input Model ──────────────────────────────────────────────────────────────

# EXTENSION POINT: Define your input model using Pydantic
class {{ToolName}}Input(BaseModel):
    """Input model for {{tool_name}}."""
    model_config = ConfigDict(
        str_strip_whitespace=True,
        validate_assignment=True,
        extra='forbid'
    )

    # Example fields:
    # query: str = Field(..., description="Search query", min_length=1)
    # limit: Optional[int] = Field(default=20, description="Max results", ge=1, le=100)


# ── Tool ─────────────────────────────────────────────────────────────────────

@mcp.tool(
    name="{{tool_name}}",
    annotations={
        "title": "{{Tool Display Name}}",
        "readOnlyHint": True,       # EXTENSION POINT: set based on tool category
        "destructiveHint": False,    # EXTENSION POINT: set based on consequence level
        "idempotentHint": True,      # EXTENSION POINT: set based on tool behavior
        "openWorldHint": True        # True if tool calls external APIs
    }
)
async def {{tool_name}}(params: {{ToolName}}Input) -> str:
    """{{description — the full routing contract from ToolDefinition}}"""
    try:
        # EXTENSION POINT: Implement the tool's logic
        # This maps to the ToolDefinition's execute() function
        data = await _call_api(params)
        return _format_response(data)
    except Exception as e:
        return _handle_error(e)


# ── API Client ───────────────────────────────────────────────────────────────

# EXTENSION POINT: Replace with your actual API call
async def _call_api(params: {{ToolName}}Input) -> Dict[str, Any]:
    """Make the API request."""
    headers = {
        "Content-Type": "application/json",
    }
    if API_KEY:
        headers["Authorization"] = f"Bearer {API_KEY}"

    async with httpx.AsyncClient() as client:
        response = await client.get(
            f"{API_BASE_URL}/{{endpoint}}",
            headers=headers,
            timeout=TIMEOUT,
        )
        response.raise_for_status()
        return response.json()


# ── Formatting ───────────────────────────────────────────────────────────────

# EXTENSION POINT: Format the response for human readability
def _format_response(data: Dict[str, Any]) -> str:
    """Format API response as human-readable text."""
    return json.dumps(data, indent=2)


def _handle_error(e: Exception) -> str:
    """Consistent error formatting."""
    if isinstance(e, httpx.HTTPStatusError):
        status = e.response.status_code
        if status == 404:
            return "Error: Resource not found."
        elif status == 403:
            return "Error: Permission denied."
        elif status == 429:
            return "Error: Rate limit exceeded. Please wait."
        return f"Error: API request failed with status {status}"
    elif isinstance(e, httpx.TimeoutException):
        return "Error: Request timed out."
    return f"Error: {type(e).__name__}: {str(e)}"


# ── Main ─────────────────────────────────────────────────────────────────────

if __name__ == "__main__":
    if not API_KEY:
        import sys
        print("WARNING: API_KEY not set. Some operations may fail.", file=sys.stderr)

    mcp.run()
